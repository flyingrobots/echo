// AUTO-GENERATED. DO NOT EDIT.
// Generated by scripts/generate_binary_codecs.mjs
#![allow(
    unused_mut,
    unused_variables,
    unused_assignments,
    unused_imports,
    clippy::let_and_return
)]

use crate::generated::type_ids::TYPEID_PAYLOAD_MOTION_V2;
use warp_core::AtomView;
use warp_core::TypeId;

const MAX_STRING_BYTES: usize = 65536;
pub const SCHEMA_HASH: &str = "0427e9fd236e92dfc8c0765f7bd429fc233bfbfab3cb67c9d03b22a0f31e7f8a";

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Theme {
    LIGHT = 0,
    DARK = 1,
    SYSTEM = 2,
}

impl Theme {
    pub fn from_u16(val: u16) -> Option<Self> {
        match val {
            0 => Some(Self::LIGHT),
            1 => Some(Self::DARK),
            2 => Some(Self::SYSTEM),
            _ => None,
        }
    }
}

pub struct MotionV2View<'a> {
    raw: &'a [u8],
}
impl<'a> MotionV2View<'a> {
    #[inline]
    fn slot_i64_le(&self, slot: usize) -> i64 {
        let start = slot * 8;
        let chunk: [u8; 8] = self.raw[start..start + 8].try_into().unwrap();
        i64::from_le_bytes(chunk)
    }
    pub fn pos_raw(&self) -> [i64; 3] {
        [
            self.slot_i64_le(0),
            self.slot_i64_le(1),
            self.slot_i64_le(2),
        ]
    }
    pub fn vel_raw(&self) -> [i64; 3] {
        [
            self.slot_i64_le(3),
            self.slot_i64_le(4),
            self.slot_i64_le(5),
        ]
    }
}
impl<'a> AtomView<'a> for MotionV2View<'a> {
    const TYPE_ID: TypeId = TYPEID_PAYLOAD_MOTION_V2;
    const BYTE_LEN: usize = 48;
    #[inline]
    fn parse(bytes: &'a [u8]) -> Option<Self> {
        Some(Self { raw: bytes })
    }
}
pub struct MotionV2Builder {
    buf: [u8; 48],
}
impl MotionV2Builder {
    pub fn new(pos: [i64; 3], vel: [i64; 3]) -> Self {
        let mut buf = [0u8; 48];
        for (i, raw) in pos.into_iter().chain(vel.into_iter()).enumerate() {
            buf[i * 8..i * 8 + 8].copy_from_slice(&raw.to_le_bytes());
        }
        Self { buf }
    }
    #[inline]
    pub fn into_bytes(self) -> bytes::Bytes {
        bytes::Bytes::copy_from_slice(&self.buf)
    }
}

pub mod ops {
    use super::*;
    pub mod app_state {
        use super::*;
        pub const OP_ID: u32 = 190543078;
        pub struct Args {}
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            Some(Args {})
        }
    }
    pub mod drop_ball {
        use super::*;
        pub const OP_ID: u32 = 778504871;
        pub struct Args {}
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            Some(Args {})
        }
    }
    pub mod set_theme {
        use super::*;
        pub const OP_ID: u32 = 1822649880;
        pub struct Args {
            pub mode: Theme,
        }
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            out.extend_from_slice(&(args.mode as u16).to_le_bytes());
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            if bytes.len() < offset + 2 {
                return None;
            }
            let val = u16::from_le_bytes(bytes[offset..offset + 2].try_into().unwrap());
            let mode = Theme::from_u16(val)?;
            offset += 2;
            Some(Args { mode })
        }
    }
    pub mod route_push {
        use super::*;
        pub const OP_ID: u32 = 2216217860;
        pub struct Args {
            pub path: String,
        }
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            let b = args.path.as_bytes();
            out.extend_from_slice(&(b.len() as u32).to_le_bytes());
            out.extend_from_slice(b);
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            if bytes.len() < offset + 4 {
                return None;
            }
            let s_len = u32::from_le_bytes(bytes[offset..offset + 4].try_into().unwrap()) as usize;
            offset += 4;
            if s_len > super::super::MAX_STRING_BYTES || bytes.len() < offset + s_len {
                return None;
            }
            let path = std::str::from_utf8(&bytes[offset..offset + s_len])
                .ok()?
                .to_string();
            offset += s_len;
            Some(Args { path })
        }
    }
    pub mod toggle_nav {
        use super::*;
        pub const OP_ID: u32 = 3272403183;
        pub struct Args {}
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            Some(Args {})
        }
    }
    pub mod toast {
        use super::*;
        pub const OP_ID: u32 = 4255241313;
        pub struct Args {
            pub message: String,
        }
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            let b = args.message.as_bytes();
            out.extend_from_slice(&(b.len() as u32).to_le_bytes());
            out.extend_from_slice(b);
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            if bytes.len() < offset + 4 {
                return None;
            }
            let s_len = u32::from_le_bytes(bytes[offset..offset + 4].try_into().unwrap()) as usize;
            offset += 4;
            if s_len > super::super::MAX_STRING_BYTES || bytes.len() < offset + s_len {
                return None;
            }
            let message = std::str::from_utf8(&bytes[offset..offset + s_len])
                .ok()?
                .to_string();
            offset += s_len;
            Some(Args { message })
        }
    }
    #[cfg(feature = "dind_ops")]
    pub mod put_kv {
        use super::*;
        pub const OP_ID: u32 = 3000000001;
        pub struct Args {
            pub key: String,
            pub value: String,
        }
        pub fn encode_vars(args: &Args) -> Vec<u8> {
            let mut out = Vec::new();
            let kb = args.key.as_bytes();
            out.extend_from_slice(&(kb.len() as u32).to_le_bytes());
            out.extend_from_slice(kb);
            let vb = args.value.as_bytes();
            out.extend_from_slice(&(vb.len() as u32).to_le_bytes());
            out.extend_from_slice(vb);
            out
        }
        pub fn decode_vars(bytes: &[u8]) -> Option<Args> {
            let mut offset = 0;
            if bytes.len() < offset + 4 {
                return None;
            }
            let k_len = u32::from_le_bytes(bytes[offset..offset + 4].try_into().unwrap()) as usize;
            offset += 4;
            if k_len > super::super::MAX_STRING_BYTES || bytes.len() < offset + k_len {
                return None;
            }
            let key = std::str::from_utf8(&bytes[offset..offset + k_len])
                .ok()?
                .to_string();
            offset += k_len;
            if bytes.len() < offset + 4 {
                return None;
            }
            let v_len = u32::from_le_bytes(bytes[offset..offset + 4].try_into().unwrap()) as usize;
            offset += 4;
            if v_len > super::super::MAX_STRING_BYTES || bytes.len() < offset + v_len {
                return None;
            }
            let value = std::str::from_utf8(&bytes[offset..offset + v_len])
                .ok()?
                .to_string();
            offset += v_len;
            Some(Args { key, value })
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use echo_wasm_abi::pack_intent_v1;

    #[test]
    fn test_golden_set_theme() {
        // setTheme(DARK)
        // OpID: 1822649880 (0x6ca33218) -> LE: 18 32 A3 6C
        // Args: mode=Theme::DARK (1) -> u16 LE: 01 00
        // Vars Len: 2 -> 02 00 00 00
        // Envelope: EINT + OpID + Len + Vars
        let args = ops::set_theme::Args { mode: Theme::DARK };
        let vars = ops::set_theme::encode_vars(&args);
        let packed = pack_intent_v1(ops::set_theme::OP_ID, &vars);

        let expected_vars = vec![0x01, 0x00];
        assert_eq!(vars, expected_vars, "Vars mismatch");

        let expected_header = b"EINT";
        let expected_op = 1822649880u32.to_le_bytes();
        let expected_len = 2u32.to_le_bytes();

        let mut expected = Vec::new();
        expected.extend_from_slice(expected_header);
        expected.extend_from_slice(&expected_op);
        expected.extend_from_slice(&expected_len);
        expected.extend_from_slice(&expected_vars);

        assert_eq!(packed, expected, "Envelope mismatch");
    }
}
