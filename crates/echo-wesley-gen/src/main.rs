// SPDX-License-Identifier: Apache-2.0
// © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots>
//! CLI that reads Wesley IR JSON from stdin and emits Rust structs/enums for Echo.

use anyhow::Result;
use clap::Parser;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::io::{self, Read};

/// Create an identifier safely, falling back to a raw identifier for Rust keywords.
fn safe_ident(name: &str) -> proc_macro2::Ident {
    syn::parse_str::<proc_macro2::Ident>(name)
        .unwrap_or_else(|_| proc_macro2::Ident::new_raw(name, proc_macro2::Span::call_site()))
}

mod ir;
use ir::{OpKind, TypeKind, WesleyIR};

#[derive(Parser)]
#[command(
    author,
    version,
    about = "Generates Echo Rust artifacts from Wesley IR"
)]
struct Args {
    /// Optional output path (defaults to stdout)
    #[arg(short, long)]
    out: Option<std::path::PathBuf>,
}

fn main() -> Result<()> {
    let args = Args::parse();

    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

    let ir: WesleyIR = serde_json::from_str(&buffer)?;
    validate_version(&ir)?;
    let code = generate_rust(&ir)?;

    if let Some(path) = args.out {
        std::fs::write(path, code)?;
    } else {
        println!("{}", code);
    }

    Ok(())
}

fn generate_rust(ir: &WesleyIR) -> Result<String> {
    let mut tokens = quote! {
        // Generated by echo-wesley-gen. Do not edit.
        use serde::{Serialize, Deserialize};
    };

    // Metadata constants
    let schema_sha = ir.schema_sha256.as_deref().unwrap_or("");
    let codec_id = ir.codec_id.as_deref().unwrap_or("cbor-canon-v1");
    let registry_version = ir.registry_version.unwrap_or(1);

    tokens.extend(quote! {
        pub const SCHEMA_SHA256: &str = #schema_sha;
        pub const CODEC_ID: &str = #codec_id;
        pub const REGISTRY_VERSION: u32 = #registry_version;
    });

    for type_def in &ir.types {
        let name = safe_ident(&type_def.name);

        match type_def.kind {
            TypeKind::Enum => {
                let variants = type_def.values.iter().map(|v| safe_ident(v));
                tokens.extend(quote! {
                    #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
                    pub enum #name {
                        #(#variants),*
                    }
                });
            }
            TypeKind::Object => {
                let fields = type_def.fields.iter().map(|f| {
                    let field_name = safe_ident(&f.name);
                    let base_ty = map_type(&f.type_name);
                    let list_ty: TokenStream = if f.list {
                        quote! { Vec<#base_ty> }
                    } else {
                        quote! { #base_ty }
                    };

                    if f.required {
                        quote! { pub #field_name: #list_ty }
                    } else {
                        quote! { pub #field_name: Option<#list_ty> }
                    }
                });

                tokens.extend(quote! {
                    #[derive(Debug, Clone, Serialize, Deserialize)]
                    pub struct #name {
                        #(#fields),*
                    }
                });
            }
            _ => {} // Ignore scalars/interfaces for now
        }
    }

    if !ir.ops.is_empty() {
        tokens.extend(quote! {
            // Registry provider types (Echo runtime loads an app-supplied implementation).
            use echo_registry_api::{ArgDef, EnumDef, ObjectDef, OpDef, OpKind, RegistryInfo, RegistryProvider};
        });

        let mut enum_defs: Vec<_> = ir
            .types
            .iter()
            .filter(|t| t.kind == TypeKind::Enum)
            .collect();
        enum_defs.sort_unstable_by(|a, b| a.name.cmp(&b.name));

        for en in &enum_defs {
            let values_ident = format_ident!("ENUM_{}_VALUES", en.name.to_ascii_uppercase());
            let values = en.values.iter();
            tokens.extend(quote! {
                pub const #values_ident: &[&str] = &[
                    #(#values),*
                ];
            });
        }

        let enum_entries = enum_defs.iter().map(|en| {
            let name = &en.name;
            let values_ident = format_ident!("ENUM_{}_VALUES", en.name.to_ascii_uppercase());
            quote! { EnumDef { name: #name, values: #values_ident } }
        });

        tokens.extend(quote! {
            pub const ENUMS: &[EnumDef] = &[
                #(#enum_entries),*
            ];
        });

        let mut obj_defs: Vec<_> = ir
            .types
            .iter()
            .filter(|t| t.kind == TypeKind::Object)
            .collect();
        obj_defs.sort_unstable_by(|a, b| a.name.cmp(&b.name));

        for obj in &obj_defs {
            let fields_ident = format_ident!("OBJ_{}_FIELDS", obj.name.to_ascii_uppercase());
            let fields = obj.fields.iter().map(|f| {
                let name = &f.name;
                let ty = &f.type_name;
                let required = f.required;
                let list = f.list;
                quote! { ArgDef { name: #name, ty: #ty, required: #required, list: #list } }
            });
            tokens.extend(quote! {
                pub const #fields_ident: &[ArgDef] = &[
                    #(#fields),*
                ];
            });
        }

        let obj_entries = obj_defs.iter().map(|obj| {
            let name = &obj.name;
            let fields_ident = format_ident!("OBJ_{}_FIELDS", obj.name.to_ascii_uppercase());
            quote! { ObjectDef { name: #name, fields: #fields_ident } }
        });

        tokens.extend(quote! {
            pub const OBJECTS: &[ObjectDef] = &[
                #(#obj_entries),*
            ];
        });

        let mut ops_sorted: Vec<_> = ir.ops.iter().collect();
        ops_sorted.sort_unstable_by_key(|op| op.op_id);

        // Op ID constants + arg descriptors (sorted by op_id for deterministic iteration).
        for op in &ops_sorted {
            let const_name = op_const_ident(&op.name, op.op_id);
            let args_name = format_ident!("{}_ARGS", const_name);
            let op_id = op.op_id;
            let args = op.args.iter().map(|a| {
                let name = &a.name;
                let ty = &a.type_name;
                let required = a.required;
                let list = a.list;
                quote! { ArgDef { name: #name, ty: #ty, required: #required, list: #list } }
            });
            tokens.extend(quote! {
                pub const #const_name: u32 = #op_id;
                pub const #args_name: &[ArgDef] = &[
                    #(#args),*
                ];
            });
        }

        // OPS table (sorted by op_id).
        let ops_entries = ops_sorted.iter().map(|op| {
            let kind = match op.kind {
                OpKind::Query => quote! { OpKind::Query },
                OpKind::Mutation => quote! { OpKind::Mutation },
            };
            let name = &op.name;
            let op_id = op.op_id;
            let args_name = format_ident!("{}_ARGS", op_const_ident(&op.name, op.op_id));
            let result_ty = &op.result_type;
            quote! { OpDef { kind: #kind, name: #name, op_id: #op_id, args: #args_name, result_ty: #result_ty } }
        });

        tokens.extend(quote! {
            pub const OPS: &[OpDef] = &[
                #(#ops_entries),*
            ];

            /// Lookup an op by ID.
            pub fn op_by_id(op_id: u32) -> Option<&'static OpDef> {
                OPS.iter().find(|op| op.op_id == op_id)
            }

            /// Lookup an op by kind + name (useful for dev tooling, not for runtime intent routing).
            pub fn op_by_name(kind: OpKind, name: &str) -> Option<&'static OpDef> {
                OPS.iter().find(|op| op.kind == kind && op.name == name)
            }

            /// Application-supplied registry provider implementation (generated from Wesley IR).
            pub struct GeneratedRegistry;

            impl RegistryProvider for GeneratedRegistry {
                fn info(&self) -> RegistryInfo {
                    RegistryInfo {
                        codec_id: CODEC_ID,
                        registry_version: REGISTRY_VERSION,
                        schema_sha256_hex: SCHEMA_SHA256,
                    }
                }

                fn op_by_id(&self, op_id: u32) -> Option<&'static OpDef> {
                    op_by_id(op_id)
                }

                fn all_ops(&self) -> &'static [OpDef] {
                    OPS
                }

                fn all_enums(&self) -> &'static [EnumDef] {
                    ENUMS
                }

                fn all_objects(&self) -> &'static [ObjectDef] {
                    OBJECTS
                }
            }

            pub static REGISTRY: GeneratedRegistry = GeneratedRegistry;
        });
    }

    let syntax_tree = syn::parse2(tokens)?;
    Ok(prettyplease::unparse(&syntax_tree))
}

fn op_const_ident(name: &str, op_id: u32) -> proc_macro2::Ident {
    let mut out = String::new();
    for (i, c) in name.chars().enumerate() {
        if c.is_alphanumeric() {
            if c.is_uppercase() && i > 0 {
                out.push('_');
            }
            out.push(c.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        return format_ident!("OP_ID_{}", op_id);
    }
    format_ident!("OP_{}", out)
}

fn validate_version(ir: &WesleyIR) -> Result<()> {
    const SUPPORTED: &str = "echo-ir/v1";
    match ir.ir_version.as_deref() {
        Some(SUPPORTED) => Ok(()),
        Some(other) => anyhow::bail!(
            "Unsupported ir_version '{}'; expected '{}'. Please regenerate IR with a compatible generator.",
            other,
            SUPPORTED
        ),
        None => anyhow::bail!(
            "Missing ir_version; expected '{}'. Regenerate IR with a current @wesley/generator-echo.",
            SUPPORTED
        ),
    }
}

/// Map a GraphQL base type name to a Rust type used in generated DTOs.
///
/// GraphQL `Float` intentionally maps to `f32` (not `f64`) so generated types
/// integrate cleanly with Echo’s deterministic scalar foundation.
fn map_type(gql_type: &str) -> TokenStream {
    match gql_type {
        "Boolean" => quote! { bool },
        "String" => quote! { String },
        "Int" => quote! { i32 },
        "Float" => quote! { f32 },
        "ID" => quote! { String },
        other => {
            let ident = safe_ident(other);
            quote! { #ident }
        }
    }
}
