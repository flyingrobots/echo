// SPDX-License-Identifier: Apache-2.0
// © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots>
//! CLI that reads Wesley IR JSON from stdin and emits Rust structs/enums for Echo.

use anyhow::Result;
use clap::Parser;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::io::{self, Read};

mod ir;
use ir::{TypeKind, WesleyIR};

#[derive(Parser)]
#[command(
    author,
    version,
    about = "Generates Echo Rust artifacts from Wesley IR"
)]
struct Args {
    /// Optional output path (defaults to stdout)
    #[arg(short, long)]
    out: Option<std::path::PathBuf>,
}

fn main() -> Result<()> {
    let args = Args::parse();

    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

    let ir: WesleyIR = serde_json::from_str(&buffer)?;
    validate_version(&ir)?;
    let code = generate_rust(&ir)?;

    if let Some(path) = args.out {
        std::fs::write(path, code)?;
    } else {
        println!("{}", code);
    }

    Ok(())
}

fn generate_rust(ir: &WesleyIR) -> Result<String> {
    let mut tokens = quote! {
        // Generated by echo-wesley-gen. Do not edit.
        use serde::{Serialize, Deserialize};
    };

    // Metadata constants
    let schema_sha = ir.schema_sha256.as_deref().unwrap_or("");
    let codec_id = ir.codec_id.as_deref().unwrap_or("cbor-canon-v1");
    let registry_version = ir.registry_version.unwrap_or(1);

    tokens.extend(quote! {
        pub const SCHEMA_SHA256: &str = #schema_sha;
        pub const CODEC_ID: &str = #codec_id;
        pub const REGISTRY_VERSION: u32 = #registry_version;
    });

    for type_def in &ir.types {
        let name = format_ident!("{}", type_def.name);

        match type_def.kind {
            TypeKind::Enum => {
                let variants = type_def.values.iter().map(|v| format_ident!("{}", v));
                tokens.extend(quote! {
                    #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
                    pub enum #name {
                        #(#variants),*
                    }
                });
            }
            TypeKind::Object => {
                let fields = type_def.fields.iter().map(|f| {
                    let field_name = format_ident!("{}", f.name);
                    let base_ty = map_type(&f.type_name);
                    let list_ty: TokenStream = if f.list {
                        quote! { Vec<#base_ty> }
                    } else {
                        quote! { #base_ty }
                    };

                    if f.required {
                        quote! { pub #field_name: #list_ty }
                    } else {
                        quote! { pub #field_name: Option<#list_ty> }
                    }
                });

                tokens.extend(quote! {
                    #[derive(Debug, Clone, Serialize, Deserialize)]
                    pub struct #name {
                        #(#fields),*
                    }
                });
            }
            _ => {} // Ignore scalars/interfaces for now
        }
    }

    if !ir.ops.is_empty() {
        tokens.extend(quote! {
            // Operation IDs (generated from Wesley IR)
        });

        for op in &ir.ops {
            let const_name = op_const_ident(&op.name);
            let op_id = op.op_id;
            tokens.extend(quote! {
                pub const #const_name: u32 = #op_id;
            });
        }
    }

    let syntax_tree = syn::parse2(tokens)?;
    Ok(prettyplease::unparse(&syntax_tree))
}

fn op_const_ident(name: &str) -> proc_macro2::Ident {
    let mut out = String::new();
    for (i, c) in name.chars().enumerate() {
        if c.is_alphanumeric() {
            if c.is_uppercase() && i > 0 {
                out.push('_');
            }
            out.push(c.to_ascii_uppercase());
        } else {
            out.push('_');
        }
    }
    if out.is_empty() {
        out.push_str("OP_UNKNOWN");
    }
    format_ident!("OP_{}", out)
}

fn validate_version(ir: &WesleyIR) -> Result<()> {
    const SUPPORTED: &str = "echo-ir/v1";
    match ir.ir_version.as_deref() {
        Some(SUPPORTED) => Ok(()),
        Some(other) => anyhow::bail!(
            "Unsupported ir_version '{}'; expected '{}'. Please regenerate IR with a compatible generator.",
            other,
            SUPPORTED
        ),
        None => anyhow::bail!(
            "Missing ir_version; expected '{}'. Regenerate IR with a current @wesley/generator-echo.",
            SUPPORTED
        ),
    }
}

fn map_type(gql_type: &str) -> TokenStream {
    match gql_type {
        "Boolean" => quote! { bool },
        "String" => quote! { String },
        "Int" => quote! { i32 },
        "Float" => quote! { f32 },
        "ID" => quote! { String },
        other => {
            let ident = format_ident!("{}", other);
            quote! { #ident }
        }
    }
}
