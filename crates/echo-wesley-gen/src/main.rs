// SPDX-License-Identifier: Apache-2.0
// © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots>
//! CLI that reads Wesley IR JSON from stdin and emits Rust structs/enums for Echo.

use anyhow::Result;
use clap::Parser;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::io::{self, Read};

mod ir;
use ir::{TypeKind, WesleyIR};

#[derive(Parser)]
#[command(
    author,
    version,
    about = "Generates Echo Rust artifacts from Wesley IR"
)]
struct Args {
    /// Optional output path (defaults to stdout)
    #[arg(short, long)]
    out: Option<std::path::PathBuf>,
}

fn main() -> Result<()> {
    let args = Args::parse();

    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

    let ir: WesleyIR = serde_json::from_str(&buffer)?;
    let code = generate_rust(&ir)?;

    if let Some(path) = args.out {
        std::fs::write(path, code)?;
    } else {
        println!("{}", code);
    }

    Ok(())
}

fn generate_rust(ir: &WesleyIR) -> Result<String> {
    let mut tokens = quote! {
        // Generated by echo-wesley-gen. Do not edit.
        use serde::{Serialize, Deserialize};
    };

    for type_def in &ir.types {
        let name = format_ident!("{}", type_def.name);

        match type_def.kind {
            TypeKind::Enum => {
                let variants = type_def.values.iter().map(|v| format_ident!("{}", v));
                tokens.extend(quote! {
                    #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
                    pub enum #name {
                        #(#variants),*
                    }
                });
            }
            TypeKind::Object => {
                let fields = type_def.fields.iter().map(|f| {
                    let field_name = format_ident!("{}", f.name);
                    let base_ty = map_type(&f.type_name);
                    let list_ty: TokenStream = if f.list {
                        quote! { Vec<#base_ty> }
                    } else {
                        quote! { #base_ty }
                    };

                    if f.required {
                        quote! { pub #field_name: #list_ty }
                    } else {
                        quote! { pub #field_name: Option<#list_ty> }
                    }
                });

                tokens.extend(quote! {
                    #[derive(Debug, Clone, Serialize, Deserialize)]
                    pub struct #name {
                        #(#fields),*
                    }
                });
            }
            _ => {} // Ignore scalars/interfaces for now
        }
    }

    let syntax_tree = syn::parse2(tokens)?;
    Ok(prettyplease::unparse(&syntax_tree))
}

fn map_type(gql_type: &str) -> TokenStream {
    match gql_type {
        "Boolean" => quote! { bool },
        "String" => quote! { String },
        "Int" => quote! { i32 },
        "Float" => quote! { f32 },
        "ID" => quote! { String },
        other => {
            let ident = format_ident!("{}", other);
            quote! { #ident }
        }
    }
}
