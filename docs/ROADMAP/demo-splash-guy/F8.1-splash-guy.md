<!-- SPDX-License-Identifier: Apache-2.0 OR MIND-UCAL-1.0 -->
<!-- © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots> -->

# F8.1: Splash Guy (Demo 2)

A grid-based water balloon game demonstrating deterministic rules, lockstep networking, and intentional desync lessons. Two peers exchange inputs, per-tick fingerprints verify determinism.

**Issues:** #222, #223, #224, #225, #226

---

## T-8-1-1: Implement Splash Guy deterministic rules + state model (#222)

**User Story:** As a learner studying deterministic game design, I want a complete, simple game with deterministic rules (grid arena, water balloons, fuse timers, chain reactions) so that I can see how all state transitions are pure functions of inputs.

**Requirements:**

- R1: Define the game state model: grid (NxM), player positions, balloon placements (position + fuse timer), explosion masks, score.
- R2: Implement deterministic rules: player movement (4-directional, collision with walls), balloon placement (fuse countdown per tick), explosion propagation (chain reactions via adjacency), player elimination.
- R3: All state is stored as Echo graph nodes/edges using Wesley-generated types.
- R4: State transitions are pure functions of (current state, admitted inputs) with no HostTime dependency.
- R5: Compute a per-tick `state_fingerprint` (hash of the full game state) for determinism verification.

**Acceptance Criteria:**

- [ ] AC1: Unit test: a scripted 20-tick game produces a deterministic final state hash (golden vector).
- [ ] AC2: Unit test: two runs with identical inputs produce identical per-tick fingerprint sequences.
- [ ] AC3: Chain reaction test: 3 adjacent balloons detonate in sequence, producing expected explosion pattern.
- [ ] AC4: Player elimination test: player caught in explosion is removed from the game state.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** Game state model, deterministic rules, per-tick fingerprinting.
**Out of Scope:** Networking (T-8-1-2); rendering (T-8-1-4); AI opponents.

**Test Plan:**

- **Goldens:** Golden state hash for a scripted 20-tick game with 2 players, 5 balloon placements.
- **Failures:** Invalid move (off-grid) is rejected; balloon placement on occupied cell is rejected.
- **Edges:** Two balloons detonating on the same tick; player at grid boundary; grid completely filled with explosions.
- **Fuzz/Stress:** Property test: random input sequences always produce valid game states (no panics, no NaN, all positions in-bounds).

**Blocked By:** none (MS-4 is an external blocker at the feature level)
**Blocking:** T-8-1-2, T-8-1-3, T-8-1-4

**Est. Hours:** 6h
**Expected Complexity:** ~500 LoC

---

## T-8-1-2: Implement Splash Guy lockstep input protocol + two-peer harness (#223)

**User Story:** As a learner studying deterministic networking, I want a lockstep protocol that exchanges player inputs between two peers and verifies per-tick fingerprints so that I can see how networked determinism works in practice.

**Requirements:**

- R1: Implement a lockstep input protocol: each peer sends its input for tick T, waits for the other peer's input, then both advance.
- R2: Each peer computes `state_fingerprint` after advancing and exchanges it; mismatch triggers a desync alert.
- R3: Two-peer harness: a test binary that runs two Echo instances in the same process (or via loopback), exchanging inputs via channels.
- R4: Support configurable simulated latency (delay input delivery by N ticks) to test buffering.
- R5: Log input exchange and fingerprint comparison for debugging.

**Acceptance Criteria:**

- [ ] AC1: Two-peer harness completes a 100-tick game with identical final state on both peers.
- [ ] AC2: Per-tick fingerprints match on both peers for all 100 ticks.
- [ ] AC3: Harness with 3-tick simulated latency still completes correctly (inputs are buffered and applied at the correct tick).
- [ ] AC4: Desync alert fires when one peer's rules are intentionally mutated (setup for T-8-1-3).

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** Lockstep protocol, two-peer harness, fingerprint exchange, simulated latency.
**Out of Scope:** Real network transport (uses in-process channels); rollback/prediction; more than 2 peers.

**Test Plan:**

- **Goldens:** Golden per-tick fingerprint sequence for a scripted 100-tick two-peer game.
- **Failures:** One peer sends no input (timeout after N ticks, harness reports stall); peer sends input for wrong tick (rejected with error).
- **Edges:** Both peers send identical inputs (valid, should produce identical state); zero-latency (no buffering needed).
- **Fuzz/Stress:** Property test: random inputs from both peers, random latency 0-10 ticks, verify fingerprint match on every tick.

**Blocked By:** T-8-1-1
**Blocking:** T-8-1-3

**Est. Hours:** 6h
**Expected Complexity:** ~450 LoC

---

## T-8-1-3: Implement Splash Guy controlled desync lessons (#224)

**User Story:** As a learner, I want to intentionally break determinism in specific, documented ways so that I understand what goes wrong and how to detect it.

**Requirements:**

- R1: Create 3 desync scenarios, each as a toggleable flag:
    - Scenario A: Use `rand()` instead of seeded PRNG for balloon fuse timer (nondeterministic initial state).
    - Scenario B: Use floating-point `f64` instead of `DFix64`/`F32Scalar` for explosion radius (cross-platform divergence).
    - Scenario C: Process inputs in arrival order instead of canonical order (network ordering nondeterminism).
- R2: Each scenario has a before/after explanation documenting what went wrong and why.
- R3: The two-peer harness detects the desync via fingerprint mismatch and reports which tick diverged.
- R4: Each scenario is runnable via a CLI flag or feature toggle.

**Acceptance Criteria:**

- [ ] AC1: Scenario A: two peers diverge within 10 ticks when `rand()` is used.
- [ ] AC2: Scenario B: two peers on different platforms (or with different compiler settings) produce different explosion results.
- [ ] AC3: Scenario C: two peers with different network arrival order produce different game states.
- [ ] AC4: Each scenario has a doc comment explaining the lesson learned.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** 3 desync scenarios with detection and documentation.
**Out of Scope:** Desync recovery/repair; scenarios involving more than 2 peers.

**Test Plan:**

- **Goldens:** Golden "first divergent tick" for each scenario given fixed seeds/inputs.
- **Failures:** Scenario flag not set — no desync (confirms the flag is necessary).
- **Edges:** Desync on tick 0 (Scenario A with immediate divergence); desync on the last tick only.
- **Fuzz/Stress:** n/a (scenarios are deterministic given the flag).

**Blocked By:** T-8-1-2
**Blocking:** T-8-1-5

**Est. Hours:** 5h
**Expected Complexity:** ~350 LoC

---

## T-8-1-4: Implement Splash Guy minimal rendering / visualization (#225)

**User Story:** As a learner, I want a simple 2D rendering of the Splash Guy grid so that I can visually follow the game state during demos and debugging.

**Requirements:**

- R1: Render the grid as a 2D tile map (cell colors for empty, wall, player, balloon, explosion).
- R2: Display player identifiers and balloon fuse countdown numbers.
- R3: Render in the WASM browser target (using the website demo canvas from MS-4).
- R4: Support a "debug overlay" toggle showing per-tick fingerprint and tick number.
- R5: Rendering reads state via the inspector protocol (read-only, no mutation).

**Acceptance Criteria:**

- [ ] AC1: Grid renders correctly for a 10x10 arena with 2 players and 3 balloons.
- [ ] AC2: Explosion animation shows chain reaction propagation across ticks.
- [ ] AC3: Debug overlay displays current tick and state fingerprint.
- [ ] AC4: Rendering does not affect game state (verified by fingerprint comparison with and without rendering).

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** 2D grid rendering, debug overlay, browser WASM target.
**Out of Scope:** Sound effects; particle effects; mobile-specific rendering; native desktop rendering.

**Test Plan:**

- **Goldens:** Screenshot golden for a known game state (2 players, 1 active explosion, debug overlay on).
- **Failures:** Render with zero players (empty grid, no crash); render with grid larger than viewport (scrolling or clipping).
- **Edges:** All cells occupied (maximum visual density); single-cell grid.
- **Fuzz/Stress:** Maintain 60fps rendering for a 20x20 grid with 10 simultaneous explosions.

**Blocked By:** T-8-1-1
**Blocking:** T-8-1-5

**Est. Hours:** 6h
**Expected Complexity:** ~400 LoC

---

## T-8-1-5: Write Splash Guy docs — networking-first course modules (#226)

**User Story:** As a learner following the Echo tutorial path, I want structured course modules that walk me through building Splash Guy step by step so that I understand deterministic networking from first principles.

**Requirements:**

- R1: Write 4 course modules:
    - Module 1: "State is a pure function" — introduce the game state model and deterministic rules.
    - Module 2: "Lockstep means trust" — walk through the input protocol and fingerprint exchange.
    - Module 3: "Break it to understand it" — guide through the 3 desync scenarios.
    - Module 4: "See what you built" — explain the rendering path and debug overlay.
- R2: Each module includes runnable code snippets that correspond to the actual implementation.
- R3: Each module ends with a "checkpoint" — a verifiable assertion the learner can confirm (e.g., "your fingerprint at tick 20 should be 0xABCD...").
- R4: Modules are published as VitePress pages under `docs/guide/`.

**Acceptance Criteria:**

- [ ] AC1: All 4 modules are written and render correctly in VitePress.
- [ ] AC2: Code snippets in each module compile and run against the current codebase.
- [ ] AC3: Each module has at least one checkpoint assertion.
- [ ] AC4: A reviewer who is not the author can follow Module 1 from scratch and reach the checkpoint.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** 4 course modules with code snippets and checkpoints.
**Out of Scope:** Video content; interactive playground (beyond what MS-4 provides); translations.

**Test Plan:**

- **Goldens:** n/a (docs)
- **Failures:** n/a
- **Edges:** n/a
- **Fuzz/Stress:** n/a

**Blocked By:** T-8-1-3, T-8-1-4
**Blocking:** none

**Est. Hours:** 5h
**Expected Complexity:** ~800 LoC (markdown + code snippets)

---
