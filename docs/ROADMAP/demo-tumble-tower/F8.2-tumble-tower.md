<!-- SPDX-License-Identifier: Apache-2.0 OR MIND-UCAL-1.0 -->
<!-- © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots> -->

# F8.2: Tumble Tower (Demo 3)

A physics-based block stacking game demonstrating deterministic physics in progressive stages. Four physics stages build from simple AABB stacking to full friction/restitution with sleeping bodies.

**Issues:** #231, #232, #233, #234, #235, #236, #237, #238

---

## T-8-2-1: Implement Tumble Tower Stage 0 physics — 2D AABB stacking (#231)

**User Story:** As a learner studying deterministic physics, I want the simplest possible physics simulation (axis-aligned bounding boxes with gravity and stacking) so that I can understand deterministic collision detection from first principles.

**Requirements:**

- R1: Implement 2D AABB (axis-aligned bounding box) representation: position, half-extents, velocity.
- R2: Implement gravity as a constant downward acceleration applied per tick.
- R3: Implement AABB-vs-AABB overlap detection (separating axis test on 2 axes).
- R4: Implement contact resolution: push overlapping boxes apart along the minimum penetration axis; zero out velocity along the contact normal.
- R5: All arithmetic uses `F32Scalar` (or `DFix64`) — no raw `f32` operations.
- R6: Per-tick `physics_fingerprint` for determinism verification.

**Acceptance Criteria:**

- [ ] AC1: A single box dropped from height settles on the ground plane within 60 ticks.
- [ ] AC2: A stack of 5 boxes remains stable for 200 ticks (no interpenetration, no drift).
- [ ] AC3: Two runs with identical initial conditions produce identical per-tick fingerprint sequences.
- [ ] AC4: Golden vector: specific 5-box stack scenario produces a known `physics_fingerprint` at tick 200.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** AABB representation, gravity, overlap detection, contact resolution, fingerprinting.
**Out of Scope:** Rotation (Stage 1); friction/restitution (Stage 2); sleeping (Stage 3); networking.

**Test Plan:**

- **Goldens:** Golden fingerprint sequence for a 5-box drop scenario over 200 ticks.
- **Failures:** Box with zero half-extents (degenerate AABB, rejected at construction); negative gravity (boxes fly up, simulation still valid).
- **Edges:** Two boxes landing simultaneously; box exactly touching ground (zero penetration); very high stack (20 boxes).
- **Fuzz/Stress:** Property test: random initial positions and velocities for 10 boxes, verify no interpenetration after 500 ticks of settling.

**Blocked By:** none (MS-4 is an external blocker at the feature level)
**Blocking:** T-8-2-2, T-8-2-5, T-8-2-7

**Est. Hours:** 6h
**Expected Complexity:** ~450 LoC

---

## T-8-2-2: Implement Tumble Tower Stage 1 physics — rotation + angular, OBB contacts (#232)

**User Story:** As a learner progressing through the physics ladder, I want rotation and oriented bounding boxes so that I can see how angular dynamics and OBB contact detection work deterministically.

**Requirements:**

- R1: Extend body representation with rotation angle (radians, stored as `F32Scalar`) and angular velocity.
- R2: Implement OBB-vs-OBB overlap detection using separating axis theorem (4 axes for 2D).
- R3: Implement contact point computation for OBB pairs (edge-vertex and edge-edge cases).
- R4: Apply torque from off-center contact forces (moment arm x contact impulse).
- R5: All trigonometric operations use the deterministic trig backend from `warp_core::math::trig`.

**Acceptance Criteria:**

- [ ] AC1: A rotated box (30 degrees) dropped onto a flat surface produces a deterministic rotation sequence.
- [ ] AC2: Two rotated boxes collide and exchange angular momentum correctly.
- [ ] AC3: Golden vector: specific rotated-stack scenario matches known fingerprint.
- [ ] AC4: Cross-OS test: same scenario on macOS and Linux produces identical fingerprints (deterministic trig verification).

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** Rotation, angular velocity, OBB SAT, contact points, torque.
**Out of Scope:** Friction/restitution (Stage 2); sleeping (Stage 3); continuous collision detection.

**Test Plan:**

- **Goldens:** Golden fingerprint for a 3-OBB collision scenario over 100 ticks.
- **Failures:** Degenerate OBB (zero-width, handled as line segment); angular velocity exceeding one full rotation per tick (clamped).
- **Edges:** Boxes at exactly 0/90/180/270 degrees (axis-aligned OBB should match AABB results); two boxes with identical rotation and position (perfect overlap).
- **Fuzz/Stress:** Property test: random rotations and positions for 8 OBBs, verify SAT returns the same result as a brute-force overlap check.

**Blocked By:** T-8-2-1
**Blocking:** T-8-2-3

**Est. Hours:** 6h
**Expected Complexity:** ~500 LoC

---

## T-8-2-3: Implement Tumble Tower Stage 2 physics — friction + restitution (#233)

**User Story:** As a learner progressing through the physics ladder, I want friction and restitution (bounce) so that I can see how material properties affect deterministic physics.

**Requirements:**

- R1: Add per-body material properties: static friction coefficient, dynamic friction coefficient, restitution (coefficient of restitution).
- R2: Implement Coulomb friction model at contact points: tangential impulse clamped by `mu * normal_impulse`.
- R3: Implement restitution: relative velocity along contact normal scaled by coefficient of restitution to compute bounce impulse.
- R4: Combined material properties for a contact pair: use geometric mean for friction, max for restitution (configurable).
- R5: All fixed-point / scalar arithmetic remains deterministic across platforms.

**Acceptance Criteria:**

- [ ] AC1: A box dropped on a high-friction surface stops sliding within 20 ticks.
- [ ] AC2: A box dropped on a zero-friction surface slides indefinitely (velocity does not decay).
- [ ] AC3: A bouncy box (restitution = 0.9) bounces at least 5 times before settling.
- [ ] AC4: Golden vector: specific friction + restitution scenario matches known fingerprint at tick 300.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** Friction model, restitution, material properties, combined material computation.
**Out of Scope:** Sleeping (Stage 3); anisotropic friction; deformable bodies.

**Test Plan:**

- **Goldens:** Golden fingerprint for a 3-body scenario with mixed materials over 300 ticks.
- **Failures:** Negative friction coefficient (clamped to 0); restitution > 1.0 (energy gain, allowed but warned).
- **Edges:** Zero restitution (perfectly inelastic collision); friction coefficient of exactly 0 vs exactly 1; two bodies with identical material properties.
- **Fuzz/Stress:** Property test: random material properties for 10 bodies, verify energy is non-increasing (within floating-point tolerance) per tick when restitution <= 1.0.

**Blocked By:** T-8-2-2
**Blocking:** T-8-2-4

**Est. Hours:** 5h
**Expected Complexity:** ~400 LoC

---

## T-8-2-4: Implement Tumble Tower Stage 3 physics — sleeping + stack stability (#234)

**User Story:** As a learner completing the physics ladder, I want sleeping bodies and stable stacks so that I can see how physics engines optimize for steady-state configurations without breaking determinism.

**Requirements:**

- R1: Implement sleep detection: a body is a sleep candidate when its linear and angular velocity magnitudes are below a threshold for N consecutive ticks.
- R2: Sleeping bodies skip integration and collision response (but remain in the broad phase for wake-up detection).
- R3: Wake-up: a sleeping body is awakened when a non-sleeping body contacts it or when an external force is applied.
- R4: Island detection: groups of mutually-contacting bodies sleep/wake as a unit.
- R5: Sleep state is included in `physics_fingerprint` (sleeping vs awake is deterministic).

**Acceptance Criteria:**

- [ ] AC1: A stack of 10 boxes settles and all bodies enter sleep within 500 ticks.
- [ ] AC2: Dropping a new box on a sleeping stack wakes the contacted bodies (and their island).
- [ ] AC3: Sleep reduces per-tick computation: a 100-body sleeping scene processes in < 50% of the time of the same scene with sleep disabled.
- [ ] AC4: Golden vector: 10-box stack scenario with sleep produces identical fingerprints to the same scenario without sleep (sleep does not change physics outcomes, only skip computation).

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** Sleep detection, wake-up, island grouping, performance optimization.
**Out of Scope:** Continuous collision detection for fast-moving bodies; adaptive timestep; GPU acceleration.

**Test Plan:**

- **Goldens:** Golden fingerprint for a 10-box stack with sleep enabled over 500 ticks (must match sleep-disabled golden).
- **Failures:** Sleep threshold of 0 (nothing ever sleeps, valid degenerate case); wake-up with no contact (external force API).
- **Edges:** Single body alone (island of 1); all bodies sleeping and no new inputs (simulation is effectively idle); body oscillating exactly at the sleep threshold.
- **Fuzz/Stress:** Benchmark: 500 bodies, measure tick time with and without sleep enabled over 1000 ticks.

**Blocked By:** T-8-2-3
**Blocking:** T-8-2-6

**Est. Hours:** 6h
**Expected Complexity:** ~450 LoC

---

## T-8-2-5: Implement Tumble Tower lockstep harness + per-tick fingerprinting (#235)

**User Story:** As a learner, I want a two-peer lockstep harness for Tumble Tower that verifies per-tick physics fingerprints so that I can confirm the physics simulation is deterministic across peers.

**Requirements:**

- R1: Adapt the Splash Guy lockstep harness (T-8-1-2) for Tumble Tower's input model (block placement position + rotation).
- R2: Exchange `physics_fingerprint` each tick between peers; mismatch triggers desync alert with the divergent tick number.
- R3: Support replaying a recorded input sequence for regression testing.
- R4: Log per-tick state summaries (body count, sleeping count, total energy) for debugging.

**Acceptance Criteria:**

- [ ] AC1: Two peers run a 200-tick Tumble Tower game with identical physics fingerprints on every tick.
- [ ] AC2: Replay of a recorded 200-tick input sequence produces identical fingerprints to the original run.
- [ ] AC3: Desync alert correctly identifies the divergent tick when one peer uses a different physics stage.
- [ ] AC4: Per-tick state summary log is emitted and parseable.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** Lockstep harness for Tumble Tower, fingerprint exchange, replay, logging.
**Out of Scope:** Real network transport; more than 2 peers; rollback/prediction.

**Test Plan:**

- **Goldens:** Golden fingerprint sequence for a scripted 200-tick two-peer Tumble Tower game.
- **Failures:** Peer sends block placement outside arena bounds (rejected); replay file is truncated (run until end, report truncation).
- **Edges:** Both peers place blocks at the same position on the same tick; zero-input game (just gravity).
- **Fuzz/Stress:** Property test: random block placements for 2 peers over 300 ticks, verify fingerprint match.

**Blocked By:** T-8-2-1
**Blocking:** T-8-2-6

**Est. Hours:** 5h
**Expected Complexity:** ~350 LoC

---

## T-8-2-6: Implement Tumble Tower controlled desync breakers — physics edition (#236)

**User Story:** As a learner, I want to intentionally break physics determinism in specific ways so that I understand why deterministic math and canonical ordering matter for physics simulations.

**Requirements:**

- R1: Create 3 physics desync scenarios, each as a toggleable flag:
    - Scenario A: Use `f32::sin`/`f32::cos` instead of the deterministic trig backend (cross-OS divergence in rotation).
    - Scenario B: Resolve contacts in HashMap iteration order instead of canonical order (nondeterministic resolution).
    - Scenario C: Use `f64` for intermediate impulse calculations and truncate to `f32` (precision-dependent results).
- R2: Each scenario has a before/after explanation.
- R3: The lockstep harness (T-8-2-5) detects each desync.

**Acceptance Criteria:**

- [ ] AC1: Scenario A: two peers on different platforms diverge within 50 ticks.
- [ ] AC2: Scenario B: two peers with different HashMap seeds diverge within 20 ticks.
- [ ] AC3: Scenario C: two peers diverge when intermediate precision differs.
- [ ] AC4: Each scenario has a doc comment explaining the physics determinism lesson.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** 3 physics desync scenarios with detection and documentation.
**Out of Scope:** Desync recovery; scenarios involving sleeping bodies specifically.

**Test Plan:**

- **Goldens:** Golden "first divergent tick" for each scenario given fixed initial conditions.
- **Failures:** Scenario flag not set — no desync.
- **Edges:** Scenario A with axis-aligned rotation (sin/cos might not diverge; ensure the test uses non-trivial angles).
- **Fuzz/Stress:** n/a

**Blocked By:** T-8-2-4, T-8-2-5
**Blocking:** T-8-2-8

**Est. Hours:** 5h
**Expected Complexity:** ~350 LoC

---

## T-8-2-7: Implement Tumble Tower visualization — 2D view + debug overlays (#237)

**User Story:** As a learner, I want a 2D visualization of Tumble Tower with debug overlays showing AABB outlines, velocity vectors, contact points, and sleep state so that I can visually understand what the physics engine is doing.

**Requirements:**

- R1: Render bodies as filled rectangles with rotation (OBB visual) in the browser WASM target.
- R2: Debug overlay toggles:
    - AABB outlines (green wireframe around the axis-aligned bounding box).
    - Velocity vectors (arrows from body center showing linear velocity direction/magnitude).
    - Contact points (red dots at contact locations, yellow for friction direction).
    - Sleep indicator (dim/grey bodies that are sleeping).
- R3: Display tick counter, body count, sleeping count, and `physics_fingerprint` in a HUD.
- R4: Rendering reads state via inspector protocol (read-only).

**Acceptance Criteria:**

- [ ] AC1: Bodies render with correct rotation and position.
- [ ] AC2: Each debug overlay toggle works independently.
- [ ] AC3: HUD displays correct tick, body count, sleeping count, and fingerprint.
- [ ] AC4: Rendering at 60fps for a 20-body scene.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** 2D body rendering, 4 debug overlays, HUD, browser WASM target.
**Out of Scope:** 3D rendering; physics stage selection UI; recording/export.

**Test Plan:**

- **Goldens:** Screenshot golden for a 5-body scene with all debug overlays enabled.
- **Failures:** Zero bodies (empty scene, HUD still visible); body with extremely high velocity (arrow clipped to viewport).
- **Edges:** Body rotated exactly 360 degrees (renders same as 0); all bodies sleeping (entire scene dimmed).
- **Fuzz/Stress:** 100 bodies with all overlays enabled, maintain > 30fps.

**Blocked By:** T-8-2-1
**Blocking:** T-8-2-8

**Est. Hours:** 6h
**Expected Complexity:** ~500 LoC

---

## T-8-2-8: Write Tumble Tower docs — physics ladder course (#238)

**User Story:** As a learner following the Echo tutorial path, I want structured course modules that walk me through the 4 physics stages so that I understand deterministic physics from AABB basics to sleeping/stability.

**Requirements:**

- R1: Write 5 course modules:
    - Module 1: "Boxes fall down" — AABB stacking, gravity, contact resolution.
    - Module 2: "Boxes spin" — rotation, OBB contacts, torque.
    - Module 3: "Boxes bounce and stick" — friction, restitution, material properties.
    - Module 4: "Boxes go to sleep" — sleeping, islands, performance.
    - Module 5: "Break the physics" — desync scenarios and lessons learned.
- R2: Each module includes runnable code snippets and a checkpoint assertion (expected fingerprint at a specific tick).
- R3: Modules are published as VitePress pages under `docs/guide/`.
- R4: Cross-reference the Splash Guy networking modules for learners doing both tracks.

**Acceptance Criteria:**

- [ ] AC1: All 5 modules are written and render correctly in VitePress.
- [ ] AC2: Code snippets compile and run against the current codebase.
- [ ] AC3: Each module has at least one checkpoint assertion with expected fingerprint.
- [ ] AC4: A reviewer can follow Module 1 from scratch and reach the checkpoint.

**Definition of Done:**

- [ ] Code reviewed and merged
- [ ] Tests pass (CI green)
- [ ] Documentation updated (if applicable)

**Scope:** 5 course modules with code snippets, checkpoints, and cross-references.
**Out of Scope:** Video content; interactive playground beyond MS-4; translations.

**Test Plan:**

- **Goldens:** n/a (docs)
- **Failures:** n/a
- **Edges:** n/a
- **Fuzz/Stress:** n/a

**Blocked By:** T-8-2-6, T-8-2-7
**Blocking:** none

**Est. Hours:** 6h
**Expected Complexity:** ~1000 LoC (markdown + code snippets)

---
