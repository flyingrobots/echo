% SPDX-License-Identifier: Apache-2.0 OR MIND-UCAL-1.0
% © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots>

\chapter{Rule Matching}
\label{chap:tour-rules}

\textbf{Entry Point:} \texttt{Engine::apply()} \\
\textbf{File:} \texttt{crates/warp-core/src/engine\_impl.rs:730-737}

\begin{bigpicture}
Now we enter the heart of Echo's reactive model. Rules are matched against graph patterns, and when they match, they're enqueued for execution. The beauty is that matching is \emph{pure}---it reads the graph but doesn't modify it.
\end{bigpicture}

\section{Function Signature}

\begin{lstlisting}[language=Rust]
pub fn apply(
    &mut self,
    tx: TxId,
    rule_name: &str,
    scope: &NodeId,
) -> Result<ApplyResult, EngineError>
\end{lstlisting}

\section{Call Trace}

\begin{verbatim}
Engine::apply(tx, rule_name, scope)
|
+-- self.rules.get(rule_name) → Option<&Rule>
|   FILE: crates/warp-core/src/rules.rs
|   Returns None if rule not registered
|
+-- rule.match_at(view, scope) → Vec<Match>
|   FILE: crates/warp-core/src/rule_matching.rs:45-89
|   |
|   +-- FOR pattern IN rule.patterns:
|       |
|       +-- pattern.try_match(view, scope) → Option<Match>
|       |   Evaluates pattern predicates against graph
|       |
|       +-- IF matched: matches.push(Match { ... })
|
+-- FOR (idx, m) IN matches.enumerate():
    |
    +-- self.scheduler.enqueue(PendingRewrite {
           tx,
           rule_id: rule.id(),
           scope: *scope,
           match_ix: idx,
           footprint: m.footprint.clone(),
       })
\end{verbatim}

\section{PendingRewrite Structure}

\textbf{File:} \texttt{crates/warp-core/src/pending.rs:12-24}

\begin{lstlisting}[language=Rust]
pub struct PendingRewrite {
    pub tx: TxId,
    pub rule_id: RuleId,
    pub scope: NodeId,
    pub match_ix: usize,       // Which match (0..N)
    pub footprint: Footprint,  // Read/write sets
}
\end{lstlisting}

\begin{commentary}
The \texttt{match\_ix} field is subtle but important. A single rule can match multiple times at the same scope (e.g., a ``connect all neighbors'' rule). Each match becomes a separate \texttt{PendingRewrite} with a different \texttt{match\_ix}.

This index is part of the canonical sort key, ensuring deterministic ordering even when multiple matches occur.
\end{commentary}

\section{Footprint Computation}

\textbf{File:} \texttt{crates/warp-core/src/footprint.rs}

\begin{lstlisting}[language=Rust]
pub struct Footprint {
    pub n_read: BTreeSet<NodeId>,   // Nodes read
    pub n_write: BTreeSet<NodeId>,  // Nodes written
    pub e_read: BTreeSet<EdgeId>,   // Edges read
    pub e_write: BTreeSet<EdgeId>,  // Edges written
    pub factor_mask: u64,           // Coarse prefilter
}
\end{lstlisting}

\begin{bigpicture}
The footprint is the foundation of BOAW's parallel safety. Two rewrites can execute in parallel if and only if their footprints don't overlap (read-read is allowed, but read-write or write-write conflicts).

The \texttt{factor\_mask} is a bloom-filter-like optimization: if the masks don't overlap, the footprints definitely don't conflict, allowing fast rejection without checking every element.
\end{bigpicture}

\begin{protip}
When designing rules, minimize footprint size. A rule that reads the entire graph can never run in parallel with anything. A rule that touches only its immediate neighbors can parallelize heavily.
\end{protip}
