// SPDX-License-Identifier: Apache-2.0
// © James Ross Ω FLYING•ROBOTS <https://github.com/flyingrobots>

import fs from "node:fs";
import path from "node:path";
import { spawnSync } from "node:child_process";
import { parseTasksDag } from "./parse-tasks-dag.js";
import { escapeDotString } from "./dag-utils.js";

const INPUT_FILE = "TASKS-DAG.md";
const OUT_DIR = "docs/assets/dags";
const DOT_FILE = path.join(OUT_DIR, "tasks-dag.dot");
const SVG_FILE = path.join(OUT_DIR, "tasks-dag.svg");
// Cluster heuristic: match known prefixes at the start of issue titles to group related work.
// Prefix list is configurable via docs/assets/dags/clusters-config.json (array of strings); we fall back to this default.
const DEFAULT_CLUSTER_PREFIXES = [
  "TT0", "TT1", "TT2", "TT3",
  "S1", "M1", "M2", "M4", "W1",
  "Demo 2", "Demo 3",
  "Spec:", "Draft", "Tooling:", "Backlog:",
];
const CLUSTER_CONFIG_PATH = path.join("docs", "assets", "dags", "clusters-config.json");

function loadClusterPrefixes() {
  try {
    const raw = fs.readFileSync(CLUSTER_CONFIG_PATH, "utf8");
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed) && parsed.every((p) => typeof p === "string")) {
      return parsed;
    }
    console.warn(`clusters-config.json is invalid (expected array of strings); using defaults.`);
  } catch (err) {
    if (err?.code !== "ENOENT") {
      console.warn(`Failed to read ${CLUSTER_CONFIG_PATH}: ${err.message}; using defaults.`);
    }
  }
  return DEFAULT_CLUSTER_PREFIXES;
}

const CLUSTER_PREFIXES = loadClusterPrefixes();

function fail(message) {
  throw new Error(message);
}

function runChecked(cmd, args) {
  const result = spawnSync(cmd, args, { encoding: "utf8", timeout: 30000, killSignal: "SIGTERM" });
  if (result.error && result.error.code === "ETIMEDOUT") {
    fail(`Command timed out: ${cmd} ${args.join(" ")}`);
  }
  if (result.timedOut || (result.status === null && result.signal === "SIGTERM")) {
    fail(`Command timed out: ${cmd} ${args.join(" ")}`);
  }
  if (result.error) fail(`Failed to run ${cmd}: ${result.error.message}`);
  if (result.status !== 0) fail(`Command failed: ${cmd} ${args.join(" ")}\n${result.stderr}`);
  return result.stdout;
}

function wrapLabel(text, maxLineLength = 30) {
  const words = String(text).split(/\s+/);
  const lines = [];
  let current = "";
  for (const word of words) {
    if (word.length > maxLineLength) {
      if (current.length) {
        lines.push(current);
        current = "";
      }
      for (let i = 0; i < word.length; i += maxLineLength) {
        lines.push(word.slice(i, i + maxLineLength));
      }
      continue;
    }
    if ((current + (current ? " " : "") + word).length > maxLineLength && current.length) {
      lines.push(current);
      current = word;
    } else {
      current = current ? `${current} ${word}` : word;
    }
  }
  if (current.length) lines.push(current);
  return lines.join("\\n");
}

function confidenceAttrs(confidence) {
  switch (confidence) {
    case "strong":
      return 'color="green3", penwidth=2.5, style="solid"';
    case "medium":
      return 'color="orange", penwidth=2.0, style="solid"';
    case "weak":
      return 'color="red", penwidth=1.0, style="dashed"';
    default:
      return 'color="gray50", penwidth=1.0, style="dotted"';
  }
}

function hashString(str) {
  let hash = 5381;
  for (let i = 0; i < str.length; i += 1) {
    hash = ((hash << 5) + hash) ^ str.charCodeAt(i); // djb2 xor variant
  }
  return Math.abs(hash);
}

// Heuristic to guess cluster name from title
function getClusterName(title) {
  for (const p of CLUSTER_PREFIXES) {
    if (title.startsWith(p)) return p.replace(/:/g, "");
  }
  return "Misc";
}

function generateDot(nodes, edges) {
  // Filter out isolated nodes to reduce clutter in the visualization (only nodes with at least one edge render).
  const connectedNodeIds = new Set();
  for (const e of edges) {
    connectedNodeIds.add(e.from);
    connectedNodeIds.add(e.to);
  }
  
  // Create a filtered map of nodes
  const filteredNodes = new Map();
  for (const [id, node] of nodes) {
    if (connectedNodeIds.has(id)) {
      filteredNodes.set(id, node);
    }
  }
  const removed = nodes.size - filteredNodes.size;
  console.log(
    `Tasks DAG: ${nodes.size} nodes total; removed ${removed} isolated node(s); rendering ${filteredNodes.size}.`,
  );

  const lines = [];
  lines.push('digraph tasks_dag {');
  lines.push('  graph [rankdir=LR, labelloc="t", fontsize=18, fontname="Helvetica", newrank=true, splines=true];');
  lines.push('  node [shape=box, style="rounded,filled", fontname="Helvetica", fontsize=10, margin="0.10,0.06"];');
  lines.push('  edge [fontname="Helvetica", fontsize=9, arrowsize=0.8];');
  lines.push('  label="Echo — Tasks DAG (from TASKS-DAG.md)\nGenerated by scripts/generate-tasks-dag.js";');
  lines.push('');

  lines.push("  subgraph cluster_legend {");
  lines.push('    label="Legend";');
  lines.push('    color="gray70";');
  lines.push('    fontcolor="gray30";');
  lines.push('    style="rounded";');
  lines.push('    LG [label="confirmed in TASKS-DAG.md", color="green", fontcolor="green"];');
  lines.push("  }");
  lines.push("");

  // Clusters
  const clusters = new Map();
  for (const node of filteredNodes.values()) {
    const cluster = getClusterName(node.title);
    if (!clusters.has(cluster)) clusters.set(cluster, []);
    clusters.get(cluster).push(node);
  }

  for (const [name, groupNodes] of clusters) {
    // Sanitize cluster name for ID
    const clusterId = "cluster_" + name.replace(/[^a-zA-Z0-9]/g, "_");
    lines.push(`  subgraph ${clusterId} {`);
    lines.push(`    label="${escapeDotString(name)}";`);
    lines.push('    style="rounded"; color="gray70";');
    // Simple color cycle for clusters
    const colors = ["#dbeafe", "#dcfce7", "#ffedd5", "#f3f4f6", "#fef9c3", "#ede9fe", "#ccfbf1", "#fee2e2"];
    const color = colors[hashString(name) % colors.length];
    lines.push(`    node [fillcolor="${color}"];`);
    
    for (const node of groupNodes) {
      const label = `#${node.number}\n${node.title}`;
      let safeLabel = wrapLabel(label, 30);
      safeLabel = escapeDotString(safeLabel);

      lines.push(`    i${node.number} [label="${safeLabel}", URL="${escapeDotString(node.url)}", tooltip="${escapeDotString(node.title)}"];`);
    }
    lines.push('  }');
  }

  lines.push('');
  for (const edge of edges) {
    if (filteredNodes.has(edge.from) && filteredNodes.has(edge.to)) {
      const attrs = confidenceAttrs(edge.confidence);
      lines.push(
        `  i${edge.from} -> i${edge.to} [${attrs}, tooltip="${escapeDotString(edge.note || "")}"];`,
      );
    }
  }

  lines.push('}');
  return lines.join("\n");
}

function main() {
  if (!fs.existsSync(INPUT_FILE)) fail(`Input file not found: ${INPUT_FILE}`);
  
  const content = fs.readFileSync(INPUT_FILE, "utf8");
  const { nodes, edges } = parseTasksDag(content);
  
  const dotContent = generateDot(nodes, edges);
  
  if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });
  fs.writeFileSync(DOT_FILE, dotContent);
  console.log(`Wrote DOT file to ${DOT_FILE}`);

  try {
    runChecked("dot", ["-Tsvg", DOT_FILE, "-o", SVG_FILE]);
    console.log(`Rendered SVG to ${SVG_FILE}`);
  } catch (e) {
    console.warn(
      "Warning: Failed to render SVG (is graphviz installed?). Only DOT file generated.",
      e?.message ?? e
    );
  }
}

main();
